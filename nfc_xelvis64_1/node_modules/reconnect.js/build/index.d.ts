export declare type initialValueOrGetter<T> = T | (() => T);
export declare type nextValueOrGetter<T> = T | ((currValue: T) => T | Promise<T>);
export declare type valueChangeListener<T> = (value: T) => void;
export declare type unregisterOutlet = () => void;
/**
 * An outlet let producers or consumers to publish or subscribe value changes.
 */
export interface Outlet<T> {
    /**
     * Subscribe to value changes.
     *
     * @param handler - The value change listener function
     * @returns A function to unregister the value change
     */
    register: (handler: valueChangeListener<T>) => unregisterOutlet;
    /**
     * Change the value backed by this outlet and publish to all subscribers.
     *
     * @param value - The value you'd like to change or a callback function to produce the value.
     */
    update: (value: nextValueOrGetter<T>) => void;
    /**
     * Get the value backed by this outlet
     */
    getValue: () => T;
    /**
     * Get the subscribers count for this outlet
     */
    getRefCnt: () => number;
}
/**
 * The options used to create an outlet.
 */
export interface OutletOptions {
    /**
     * Used to indicate whether reconnect.js should automatically remove the outlet
     * when the number of subscribers down to 0.
     */
    autoDelete?: boolean;
}
/**
 * Test if the outlet is NullOutlet singleton.
 *
 * Normally applications don't need to call this API.
 *
 * @param outlet
 * @returns a boolean value to indicate whether the outlet is the same object as NullOutlet.
 */
declare function isNull(outlet: Outlet<any>): boolean;
/**
 * Get or create an outlet using given key.
 *
 * This method first search global registry to see if the key has a corresponding outlet,
 * if so returns it. Otherwise it will create a new outlet and set to global registry,
 * then returns it.
 *
 * @param key
 * @param initialValue
 * @param options
 * @returns The created or existing outlet with given key
 */
declare function getNewOutlet<T>(key: any, initialValue: initialValueOrGetter<T>, options?: OutletOptions): Outlet<T>;
/**
 * Get an existing outlet. If not found, return the `NullOutlet` singleton.
 *
 * @param key
 * @returns The existing outlet
 */
declare function getOutlet<T>(key: any): Outlet<T>;
/**
 * Check if the outlet already exists.
 *
 * @param key
 * @returns A boolean value indicates is the outlet exists
 */
declare function hasOutlet(key: any): boolean;
/**
 * Force remove the outlet from global registry.
 *
 * @param key
 */
declare function removeOutlet(key: any, force?: boolean): void;
/**
 * [React Hook] use value and setter for an outlet. It might create new outlet if initialValue is passed,
 *
 * If the initialValue is passed, allow creating new outlet by calling getNewOutlet.
 * Otherwise, call getOutlet to retrieve existing one.
 *
 * @param key
 * @param initialValue
 * @param options
 * @returns An array with 2 elements: value and setter for the outlet, just like React.useState.
 */
declare function useOutlet<T>(key: any, initialValue?: initialValueOrGetter<T>, options?: OutletOptions): [T, (value: nextValueOrGetter<T>) => void];
/**
 * [React Hook] use setter for the outlet.
 *
 * @param key
 * @returns The setter for the outlet
 */
declare function useOutletSetter<T>(key: any): (value: nextValueOrGetter<T>) => void;
/**
 * [React Hook] declare an outlet without using its value and setter. If the outlet doesn't exist yet, create it.
 *
 * Use this hook to declare an outlet in the root component, when:
 * - the child components need a shared outlet
 * - but the root itself doesn't need either value and setter
 * So when the value is changed, the root component won't re-render.
 *
 * @param key
 * @param initialValue
 */
declare function useOutletDeclaration<T>(key: any, initialValue: initialValueOrGetter<T>): void;
declare const useNewOutlet: typeof useOutletDeclaration;
declare function getGlobalRegistry(): Map<any, any>;
export { getNewOutlet, getOutlet, hasOutlet, removeOutlet, useOutlet, useOutletSetter, useOutletDeclaration, useNewOutlet, getGlobalRegistry, isNull, };
