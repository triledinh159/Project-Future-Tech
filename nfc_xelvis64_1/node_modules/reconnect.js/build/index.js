"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isNull = exports.getGlobalRegistry = exports.useNewOutlet = exports.useOutletDeclaration = exports.useOutletSetter = exports.useOutlet = exports.removeOutlet = exports.hasOutlet = exports.getOutlet = exports.getNewOutlet = void 0;
var react_1 = __importDefault(require("react"));
var eventemitter3_1 = __importDefault(require("eventemitter3"));
var Utils = __importStar(require("./Utils"));
var registry = new Map();
var defaultOutletOptions = {
    autoDelete: true,
};
var warningMessage = "Normally it's because your outlets have been updated with hot-reload. You might need to reload your app.";
var NullOutlet = {
    register: function (handler) {
        console.error("[reconnect.js]: NullOutlet.register() shouldn't be called.\n" + warningMessage);
        return function () { return 0; };
    },
    update: function (value) {
        console.error("[reconnect.js]: NullOutlet.update() shouldn't be called.\n" + warningMessage);
    },
    getValue: function () {
        console.error("[reconnect.js]: NullOutlet.getValue() shouldn't be called.\n" + warningMessage);
    },
    getRefCnt: function () {
        console.error("[reconnect.js]: NullOutlet.getRefCnt() shouldn't be called.\n" + warningMessage);
        return 0;
    },
};
/**
 * Test if the outlet is NullOutlet singleton.
 *
 * Normally applications don't need to call this API.
 *
 * @param outlet
 * @returns a boolean value to indicate whether the outlet is the same object as NullOutlet.
 */
function isNull(outlet) {
    return Object.is(NullOutlet, outlet);
}
exports.isNull = isNull;
function Outlet(ee, key, initialValue, options) {
    var Evt = {
        update: 'update',
    };
    var refCnt = 0;
    var innerValue;
    // https://github.com/microsoft/TypeScript/issues/37663
    if (initialValue instanceof Function) {
        innerValue = initialValue();
    }
    else {
        innerValue = initialValue;
    }
    if (options === undefined) {
        options = defaultOutletOptions;
    }
    else {
        options = __assign(__assign({}, defaultOutletOptions), options);
    }
    function register(handler) {
        refCnt++;
        function onChange(value) {
            handler(value);
        }
        ee.on(Evt.update, onChange);
        return function () {
            refCnt--;
            ee.off(Evt.update, onChange);
            if (refCnt === 0) {
                if (options === null || options === void 0 ? void 0 : options.autoDelete) {
                    registry.delete(key);
                }
            }
        };
    }
    function update(value) {
        // https://github.com/microsoft/TypeScript/issues/37663
        if (value instanceof Function) {
            var resp = value(innerValue);
            if (Utils.isPromise(resp)) {
                resp.then(function (nextValue) {
                    innerValue = nextValue;
                    ee.emit(Evt.update, innerValue);
                });
            }
            else {
                innerValue = resp;
                ee.emit(Evt.update, innerValue);
            }
        }
        else {
            innerValue = value;
            ee.emit(Evt.update, innerValue);
        }
    }
    function getValue() {
        return innerValue;
    }
    function getRefCnt() {
        return refCnt;
    }
    return {
        register: register,
        update: update,
        getValue: getValue,
        getRefCnt: getRefCnt,
    };
}
/**
 * Get or create an outlet using given key.
 *
 * This method first search global registry to see if the key has a corresponding outlet,
 * if so returns it. Otherwise it will create a new outlet and set to global registry,
 * then returns it.
 *
 * @param key
 * @param initialValue
 * @param options
 * @returns The created or existing outlet with given key
 */
function getNewOutlet(key, initialValue, options) {
    if (registry.has(key)) {
        return registry.get(key);
    }
    var newOutlet = Outlet(new eventemitter3_1.default(), key, initialValue, options);
    registry.set(key, newOutlet);
    return newOutlet;
}
exports.getNewOutlet = getNewOutlet;
/**
 * Get an existing outlet. If not found, return the `NullOutlet` singleton.
 *
 * @param key
 * @returns The existing outlet
 */
function getOutlet(key) {
    if (!registry.has(key)) {
        return NullOutlet;
    }
    return registry.get(key);
}
exports.getOutlet = getOutlet;
/**
 * Check if the outlet already exists.
 *
 * @param key
 * @returns A boolean value indicates is the outlet exists
 */
function hasOutlet(key) {
    return registry.has(key);
}
exports.hasOutlet = hasOutlet;
/**
 * Force remove the outlet from global registry.
 *
 * @param key
 */
function removeOutlet(key, force) {
    var outlet = registry.get(key);
    if (outlet) {
        if (outlet.getRefCnt() === 0) {
            registry.delete(key);
        }
        else if (force) {
            registry.delete(key);
        }
    }
}
exports.removeOutlet = removeOutlet;
/**
 * [React Hook] use value and setter for an outlet. It might create new outlet if initialValue is passed,
 *
 * If the initialValue is passed, allow creating new outlet by calling getNewOutlet.
 * Otherwise, call getOutlet to retrieve existing one.
 *
 * @param key
 * @param initialValue
 * @param options
 * @returns An array with 2 elements: value and setter for the outlet, just like React.useState.
 */
function useOutlet(key, initialValue, options) {
    var outlet = react_1.default.useRef(initialValue === undefined
        ? getOutlet(key)
        : getNewOutlet(key, initialValue, options)).current;
    var _a = react_1.default.useState(outlet.getValue()), value = _a[0], setValue = _a[1];
    react_1.default.useEffect(function () {
        // Hook register and unregister to component mount and unmount.
        // By subscribing to outlet, when the outlet value changed, the internal value also changed
        // because the `setValue` is called, so out component will re-render.
        var unregister = outlet.register(setValue);
        return unregister;
    }, [outlet]);
    return [value, outlet.update];
}
exports.useOutlet = useOutlet;
/**
 * [React Hook] use setter for the outlet.
 *
 * @param key
 * @returns The setter for the outlet
 */
function useOutletSetter(key) {
    var setValue = react_1.default.useCallback(function (value) {
        getOutlet(key).update(value);
    }, []);
    return setValue;
}
exports.useOutletSetter = useOutletSetter;
/**
 * [React Hook] declare an outlet without using its value and setter. If the outlet doesn't exist yet, create it.
 *
 * Use this hook to declare an outlet in the root component, when:
 * - the child components need a shared outlet
 * - but the root itself doesn't need either value and setter
 * So when the value is changed, the root component won't re-render.
 *
 * @param key
 * @param initialValue
 */
function useOutletDeclaration(key, initialValue) {
    var initRef = react_1.default.useRef(false);
    // do this in render path directly, otherwise we might miss the initial value for our outlet
    if (!initRef.current) {
        getNewOutlet(key, initialValue, { autoDelete: false });
        initRef.current = true;
    }
    react_1.default.useEffect(function () {
        return function () {
            removeOutlet(key, true);
        };
    }, []);
}
exports.useOutletDeclaration = useOutletDeclaration;
// Just for backward capatibility to allow clients using the old function name `useNewOutlet`
// instead of the new one `useOutletDeclaration`
var useNewOutlet = useOutletDeclaration;
exports.useNewOutlet = useNewOutlet;
function getGlobalRegistry() {
    return registry;
}
exports.getGlobalRegistry = getGlobalRegistry;
